import { ApiBearerAuth, ApiBody, ApiOperation, ApiResponse, ApiTags } from "@nestjs/swagger"
import { AuthManager, JwtManager, UserRepo } from "@src/application/auth/interfaces"
import { AuthPayload, AuthTokens, UserPayload } from "@src/application/auth/dto"
import { BadRequestException, Body, Controller, Get, Post } from "@nestjs/common"
import { Domain, TonApiClient } from "@src/application/auth/interfaces/auth-manager"
import { GenereatePayload, GenereatePayloadHandler } from "@src/application/auth/commands/generate-payload"
import {
    AuthManager as ParamAuthManager,
    AuthUserRepo as ParamAuthUserRepo,
    JwtManager as ParamJwtManager,
    RefreshTokenRepo as ParamRefreshTokenRepo,
    TonApiClient as ParamTonApiClient,
    UnitOfWork as ParamUnitOfWork,
    UserPayloadFromAuthToken,
} from "@src/api/param_decorators"
import { Proof, VerifyProof, VerifyProofHandler } from "@src/application/auth/commands/verify-proof"
import { TonAddress, TonNetwork } from "@src/domain/user/types"
import { RefreshTokenRepo } from "@src/application/auth/interfaces/persistence"
import { UnitOfWork } from "@src/application/common/interfaces"

@ApiTags("Auth")
@Controller("auth")
export class AuthController {
    @ApiOperation({ summary: "Generate an auth payload for TON proof signature" })
    @ApiResponse({
        status: 201,
        description: "Auth payload",
        schema: {
            nullable: false,
            type: "object",
            properties: {
                nonce: {
                    nullable: false,
                    title: "Nonce",
                    type: "string",
                    description: "Payload nonce",
                },
            },
        },
    })
    @Post("payload")
    generateAuthPayload(
        @ParamAuthManager() authManager: AuthManager,
    ): AuthPayload {
        const payloadHandler = new GenereatePayloadHandler(authManager)
        const payload = payloadHandler.execute(new GenereatePayload())

        return payload
    }

    @ApiOperation({ summary: "Get a user payload by an auth token" })
    @ApiBearerAuth()
    @ApiResponse({
        status: 200,
        description: "User payload",
        schema: {
            nullable: false,
            type: "object",
            properties: {
                id: {
                    nullable: false,
                    title: "Id",
                    type: "string",
                    format: "uuid",
                    description: "User id",
                },
                address: {
                    nullable: false,
                    title: "Address",
                    type: "string",
                    description: "User address",
                },
            },
        },
    })
    @ApiResponse({
        status: 401,
        description: (
            "Unauthorized | " +
            "JWT token is expired | " +
            "Invalid JWT token | " +
            "Unknown JWT token error"
        ),
    })
    @Get("payload")
    getUserPayload(
        @UserPayloadFromAuthToken() userPayload: UserPayload,
    ): UserPayload {
        return userPayload
    }

    @ApiOperation({ summary: "Generate an auth tokens by a user payload and TON proof signature" })
    @ApiBody({
        schema: {
            type: "object",
            properties: {
                payloadNonce: {
                    nullable: false,
                    title: "Payload nonce",
                    type: "string",
                    description: "Payload nonce, generated by /auth/payload",
                },
                address: {
                    nullable: false,
                    title: "Address",
                    type: "string",
                    description: "User address",
                },
                network: {
                    nullable: false,
                    title: "Network",
                    examples: ["-3", "-239"],
                    type: "string",
                    description: "Blockchain network. Must be -3 or -239",
                    enum: ["-3", "-239"],
                },
                signature: {
                    nullable: false,
                    title: "Signature",
                    type: "string",
                    description: "TON proof signature",
                },
                timestamp: {
                    nullable: false,
                    title: "Timestamp",
                    type: "number",
                    description: "Timestamp of the proof signature",
                },
                domainLengthBytes: {
                    nullable: false,
                    title: "Domain length bytes",
                    type: "number",
                    description: "Domain length bytes",
                },
                domainValue: {
                    nullable: false,
                    title: "Domain value",
                    type: "string",
                    description: "Domain value",
                },
                stateInit: {
                    nullable: false,
                    title: "State init",
                    type: "string",
                    description: "State init",
                },
            },
            required: [
                "payloadNonce", "address", "network", "signature", "timestamp",
                "domainLengthBytes", "domainValue", "stateInit",
            ],
        },
    })
    @ApiResponse({
        status: 201,
        description: "Auth tokens",
        schema: {
            nullable: false,
            type: "object",
            properties: {
                accessToken: {
                    nullable: false,
                    title: "Access token",
                    type: "string",
                },
                refreshToken: {
                    nullable: false,
                    title: "Refresh token",
                    type: "string",
                },
            },
        },
    })
    @ApiResponse({
        status: 400,
        description: (
            "Address is required | " +
            "Network is required and must be -3 or -239 | " +
            "Signature is required | " +
            "Payload nonce is required | " +
            "Proof timestamp is required | " +
            "Domain length bytes is required | " +
            "Domain value is required | " +
            "State init is required"
        ),
    })
    @ApiResponse({
        status: 401,
        description: (
            "Nonce is expired | " +
            "Invalid nonce | " +
            "Uknown nonce error | " +
            "Invalid proof signature | " +
            "Payload nonce is required | " +
            "Proof timestamp is required | " +
            "Domain length bytes is required | " +
            "Domain value is required | " +
            "State init is required"
        ),
    })
    @Post()
    generateAuthToken(
        @ParamAuthUserRepo() userRepo: UserRepo,
        @ParamRefreshTokenRepo() refreshTokenRepo: RefreshTokenRepo,
        @ParamTonApiClient() tonApiClient: TonApiClient,
        @ParamAuthManager() authManager: AuthManager,
        @ParamJwtManager() jwtManager: JwtManager,
        @ParamUnitOfWork() uow: UnitOfWork,
        @Body("payloadNonce") payloadNonce?: string,
        @Body("address") address?: TonAddress,
        @Body("network") network?: TonNetwork,
        @Body("signature") proofSignature?: string,
        @Body("timestamp") proofTimestamp?: number,
        @Body("domainLengthBytes") domainLengthBytes?: number,
        @Body("domainValue") domainValue?: string,
        @Body("stateInit") stateInit?: string,
    ): Promise<AuthTokens> {
        if (!address) {
            throw new BadRequestException("Address is required")
        } else if (!network || (network !== TonNetwork.Mainnet && network !== TonNetwork.Testnet)) {
            throw new BadRequestException("Network is required and must be -3 or -239")
        } else if (!payloadNonce) {
            throw new BadRequestException("Payload nonce is required")
        } else if (!proofSignature) {
            throw new BadRequestException("Signature is required")
        } else if (!proofTimestamp) {
            throw new BadRequestException("Proof timestamp is required")
        } else if (!domainLengthBytes) {
            throw new BadRequestException("Domain length bytes is required")
        } else if (!domainValue) {
            throw new BadRequestException("Domain value is required")
        } else if (!stateInit) {
            throw new BadRequestException("State init is required")
        }

        const payload = new AuthPayload(payloadNonce)

        const domain: Domain = { lengthBytes: domainLengthBytes, value: domainValue }
        const proof = new Proof(payload.nonce, proofSignature, proofTimestamp, domain)
        const tokenHandler = new VerifyProofHandler(tonApiClient, authManager, jwtManager, userRepo, refreshTokenRepo, uow)
        const authTokens = tokenHandler.execute(new VerifyProof(address, network, proof, stateInit))
        return authTokens
    }
}
